CloneWizard_StoreInSecureStore=true
HistoryView_MaxBranchLength=50
HistoryView_MaxDiffLines=10000
HistoryView_MaxNumberOfCommmits=20000
HistoryView_MaxTagLength=50
commit_dialog_history_messages=<?xml version\="1.0" encoding\="UTF-8"?>\r\n<messages>\r\n<message>orged imports</message>\r\n<message>created coreannotationsfacades project</message>\r\n<message>improved object hierarchy</message>\r\n<message>created OrionSimpleObject that is OrionObject&apos;s empty superclass</message>\r\n<message>1</message>\r\n<message>--renamed coregeneral project to core&\#x0A;--created builders</message>\r\n<message>--created datastructures dir in which all the data structures projects&\#x0A;reside&\#x0A;--created designpatterns dir in which all the design patterns projects&\#x0A;reside</message>\r\n<message>renaming</message>\r\n<message>--created &quot;core&quot; dir in orionware-libraries and all the core projects&\#x0A;reside in there&\#x0A;--moved the stuff from the coreinitialisation project to&\#x0A;OrionObjectInitialiser and I use reflection to use the configuration and&\#x0A;annotation services so that the coregeneral project does not depend&\#x0A;directly on those 2 projects to avoid cyclic dependencies&\#x0A;--various other stuff</message>\r\n<message>created coreannotationsservices project that has the annotations&\#x0A;services and tasks only</message>\r\n<message>renamed 3 classes</message>\r\n<message>deleted RegisteredAnnotation and used OrionAnnotation instead since the&\#x0A;name &quot;registered annotation&quot; was used for annotations that have not been&\#x0A;registered yet</message>\r\n<message>created separate Ant builders for the core subprojects which are called&\#x0A;from the core build.xml</message>\r\n<message>--removed 2 configuration enums since they are unnecessary&\#x0A;--in the the buildProject Ant task now we copy also prop and xml files&\#x0A;to the binaries dir, because the builder did not actually copy those by&\#x0A;default since the Java compiler does not use such files as source files</message>\r\n<message>created CRUD operations for properties</message>\r\n<message>I don&apos;t know how to make the Ant builder for the core to include the&\#x0A;class files in the /orionware-libraries/core/bin dir as a classpath for&\#x0A;the compiler, so I made it to create a temp JAR file for each core&\#x0A;subproject and use that for the compilation. At the end of the&\#x0A;compilation it deletes those temp JARs</message>\r\n<message>split core into subprojects</message>\r\n<message>removed core libraries service, because I don&apos;t think I will have to&\#x0A;expand it a lot in the future so that it is on its own. It seems more&\#x0A;appropriate, for now at least, to be inside the configuration service</message>\r\n<message>removed service coordinators and put their logic insdie the service&\#x0A;clases themselves, because there was an unnecessary layer of abstraction&\#x0A;there because of the coordinators</message>\r\n<message>moved some dependency instantiations on the class-var level</message>\r\n<message>renamed all service helpers to service coordinators since they actually&\#x0A;coordinate tasks. It is a more descriptive name</message>\r\n<message>changed method arguments ordering</message>\r\n<message>removed direct dependency to FilesystemService</message>\r\n<message>created GatherAllAnnotationsHelper</message>\r\n<message>--created AnnotationsLoaderService that only loads annotations file&\#x0A;streams&\#x0A;--deleted AnnotationsConfigurationService, because we do not configure&\#x0A;annotations&\#x0A;--moved a few service methods from the old&\#x0A;AnnotaitonsConfigurationService to AnnotationsRegistrationService,&\#x0A;because they belong there conceptually</message>\r\n<message>renamed var for consistency</message>\r\n<message>renamed a few service tasks for better naming</message>\r\n<message>renamed all service helpers&apos; methods to just &quot;run&quot;, for convenience and&\#x0A;consistency</message>\r\n<message>created helper for AnnotationsRegistrationService</message>\r\n<message>created 2 helpers for AnnotationsProcessorService</message>\r\n<message>housekeeping</message>\r\n<message>removed 2 convenience methods from AnnotationsConfigurationService</message>\r\n<message>--created GetAnnotationsFileStreamHelper</message>\r\n<message>updated</message>\r\n<message>created LoadLibrariesAnnotationsHelper</message>\r\n<message>created RegisterAnnotationHelper</message>\r\n<message>created OrionServiceHelper interface that service helper classes&\#x0A;&quot;implement&quot; (it is a marker interface). A service helper has methods in&\#x0A;it for a specific service method. The service will call these methods in&\#x0A;the helper in the order it needs to accomplish the task</message>\r\n<message>deleted @TaskInjector annotation</message>\r\n<message>created RegisterAnnotationTask</message>\r\n<message>in IF and WHILEs where we have conditions, I put those lines of&\#x0A;condition in private methods and gave them a good names for increased&\#x0A;readability</message>\r\n<message>used StringBuilder everywhere we did string concatenation</message>\r\n<message>using @TaskInjector instead of the generic @Injector</message>\r\n<message>made the @TaskInjector to be able to take just the task class name and&\#x0A;based on the class that is actually requesting to be injected with the&\#x0A;task (a service class that requests it), we get the package of this&\#x0A;class and manipulate it to follow the pattern of the location of this&\#x0A;service class&apos;s task</message>\r\n<message>created TaskInjector annotation which works like the ServiceInjector,&\#x0A;except it is for service tasks</message>\r\n<message>used @ServiceInjector instead of the generic @Injector</message>\r\n<message>created test for the service injector</message>\r\n<message>created ServiceInjector annotation that is a special case of the generic&\#x0A;Injector. When we use it, the format is&\#x0A;package1.package2.services.servicename.ServiceInterface&\#x0A;and now we transform it to&\#x0A;package1.package2.services.servicename.impl.ServiceInterfaceImpl.&\#x0A;This way, in your own class, you do not have to actually know the&\#x0A;implementation class package and name. Since we have a pattern as to&\#x0A;service implementations when it comes to the package they are in their&\#x0A;name, the service dependency injector dynamically builds that package&\#x0A;and service implementation class name, based on the service interface&\#x0A;(which you have already declared inside the&\#x0A;@ServiceInjector(ID\=&quot;.........&quot;). It extracts the package and the&\#x0A;service interface name and builds the package and name of the&\#x0A;implementation</message>\r\n<message>refactoring</message>\r\n<message>renamed forEach() to forEachAnnotation() since it was not clear what we&\#x0A;are looping through</message>\r\n<message>removed getProps() from AllProperties an dmade properties instance var&\#x0A;public since the OrionRegistry manipulates it anyway</message>\r\n<message>moved forEach() from RegisteredAnnotations to OrionRegistry since we&\#x0A;should manipulate the annotations through the registry</message>\r\n<message>created OrionRegistry that holds references to static resources like&\#x0A;AllProperties and RegisteredAnnotations</message>\r\n<message>removed all object dependencies builders and moved the object&\#x0A;dependencies instantiations inside the objects&apos; constructors</message>\r\n<message>created library properties registration service</message>\r\n<message>split GatherAllObjectAnnotationsTask into 4 distinct ones and it uses&\#x0A;them</message>\r\n<message>deleted unused class</message>\r\n<message>created annotations registration service that is responsible for&\#x0A;registering library annotations</message>\r\n<message>methods rename</message>\r\n<message>this method needs to vars from the LibraryConfiguration object. So,&\#x0A;instead of passing to it all the vars from the object, we pass it the&\#x0A;object itself and the method will extract from it whatever it needs to&\#x0A;operate</message>\r\n<message>removed a null check from 2 service tasks, because they should assume&\#x0A;that the input is correct, valid and good. It is the &quot;caller&apos;s&quot;&\#x0A;responsibility to make sure he sends the correct stuff to the services</message>\r\n<message>removed unnecessary &quot;null&quot; initialisations</message>\r\n<message>removed unnecessary comment</message>\r\n<message>unnecessary cast</message>\r\n<message>organised imports</message>\r\n<message>cleaned code \= GetClasspathRootTask already returns the absolute path,&\#x0A;so I did not need to create another file and call getAbsolutePath()</message>\r\n<message>created a few more object dependencies builders</message>\r\n<message>created more object dependencies builders</message>\r\n<message>created an object dependencies builder. It is used by the core project,&\#x0A;because it does not use the @Injector annotation</message>\r\n<message>converted all library configuration classes with static vars to enums</message>\r\n<message>deleted AnnotationsFileStreamService, because I noticed that a few other&\#x0A;services have stream-related methods in there and I would have to&\#x0A;essentially copy paste the AnnotationsFileStreamService to the others,&\#x0A;as well</message>\r\n<message>extracted 3 service methods into a new service</message>\r\n<message>converted a few configuration classes to normal objects without static&\#x0A;vars</message>\r\n<message>made DataStructuresConfiguration a normal object without static vars</message>\r\n<message>made CoreConfiguration a normal object without static vars</message>\r\n<message>reverted Injector annotation changes. It will stay as a setter method&\#x0A;annotation (at least for a while, until I figure out how to make the&\#x0A;annotation work for constructors without a StackOverflowError</message>\r\n<message>I am in the middle of converting the Injector annotation to work with&\#x0A;constructors</message>\r\n<message>split some methods into smaller private ones</message>\r\n<message>renamed a method and updated references</message>\r\n<message>made the ListFactoryService able to create an empty list with any type&\#x0A;we pass</message>\r\n<message>moved condition from constructor outside</message>\r\n<message>--created OrionProperties extends java.util.Properties for convenience&\#x0A;so that I can &quot;isNotEmpty()&quot;&\#x0A;--AllProperties.java now has a reference to all the properties&\#x0A;registered which is held by an OrionProperties object&\#x0A;--updated references</message>\r\n<message>used StringBuilder everywhere I have at least 1 string concatenation</message>\r\n<message>refactored a field&apos;s init place</message>\r\n<message>created wrapper annotations service</message>\r\n<message>init and unfinished commit of some classes in datastructuresservices and&\#x0A;initial attempt to refactor the way general library objects send their&\#x0A;directories to OrionObject as Triples</message>\r\n<message>generic Pair and Triple objects</message>\r\n<message>repackaged</message>\r\n<message>--organised imports&\#x0A;--refactored test suites</message>\r\n<message>converted OrionTask from abstract class to interface. It is not&\#x0A;necessary since there are no methods in it to denote behaviour, but I&\#x0A;did it so that tasks from other projects (like datastructuresservices)&\#x0A;can extend DataStructureObject so that we can enable dependency&\#x0A;injection</message>\r\n<message>renamed test suite and updated references</message>\r\n<message>--created more convenience methods for filtering, forEach for both&\#x0A;--created test, as well</message>\r\n<message>renamed</message>\r\n<message>created filtering method</message>\r\n<message>removed the name of the service from all the service tasks class names&\#x0A;to make them smaller in the &quot;core&quot; project</message>\r\n<message>removed all facades from &quot;core&quot; project</message>\r\n<message>created workspace cleaner that empties some of the (sub)directories&\#x0A;inside .metadata, because Eclipse does not actually need them and they&\#x0A;just occupy space</message>\r\n<message>removed 2 projects</message>\r\n<message>new libraries</message>\r\n<message>added new projects</message>\r\n<message>created Eclipse project and builder</message>\r\n<message>created Eclipse project</message>\r\n<message>created call method task for reflection service</message>\r\n<message>created makeMethodAccessible task that takes a method and if it private&\#x0A;it makes it callable</message>\r\n<message>updated references</message>\r\n<message>removed the filter for not null Method, because the redflection service&\#x0A;already does that</message>\r\n<message>--renamed&\#x0A;--updated references</message>\r\n<message>created reflection service that takes an OrionObject and returns an&\#x0A;array of not null Method[]</message>\r\n<message>added executeAndReturnAdday() which is a normal execute(), but it&\#x0A;returns specifically an array, because Object \!\= Object[]</message>\r\n<message>converted abstract interfaces to just interfaces, because apparently&\#x0A;&quot;abstract&quot; is obsolete</message>\r\n<message>temp commit</message>\r\n<message>created delete project from cloning scripts tool</message>\r\n<message>corrected a mistake</message>\r\n<message>--created edit project in cloning script&\#x0A;--corrected a reference in AddProjectToCloningScript</message>\r\n<message>repackaged and updated references</message>\r\n<message>created AddProjectToCloningScript tool</message>\r\n<message>created some file utilities</message>\r\n<message>init commit of AddProjectToCloningScript</message>\r\n<message>made the setters that use the @Injector private to increase&\#x0A;encapsulation</message>\r\n<message>created tests for data structure size service</message>\r\n<message>created service, task and facade for data structure size. Initially it&\#x0A;calculates the size of the provided data structure</message>\r\n<message>this class will be extended by all classes in this project in order to&\#x0A;enable the dependency injector</message>\r\n<message>1--added JUnit to the classpath&\#x0A;2--added projectName parameter to the builder</message>\r\n<message>changed package structure</message>\r\n<message>created tests for the dependency injection</message>\r\n<message>created CoreObject. It has a constructor that calls the dependency&\#x0A;injection facade by passing itself as a parameter and then its&\#x0A;subclasses that have used the @Injector annotation, have their&\#x0A;dependencies instantiated and injected. The CoreObject is subclassed by&\#x0A;all classes inside the core project. There will be an equivalent object&\#x0A;for the other projects</message>\r\n<message>created facade for the dependency injection service</message>\r\n<message>created the dependency injection service and corresponding task. It&\#x0A;takes an object and it scans (for now) the Injector annotation, it&\#x0A;extracts the class location and name, instantiates it and uses the&\#x0A;appropriate setter inside the input object to inject this new&\#x0A;object/dependency</message>\r\n<message>created a generic OrionException</message>\r\n<message>created a dependency injector annotation. It can be used right before&\#x0A;setters. There is the ID parameters in which you provide the complete&\#x0A;package and class name of the class you want to inject to the class you&\#x0A;want</message>\r\n<message>moved classes around</message>\r\n<message>1--added testsrc dir to classpath&\#x0A;2--added .gitignore&\#x0A;3--added Eclipse project settings&\#x0A;4--added projectName to the builder</message>\r\n<message>changed project names</message>\r\n<message>added projectName to the builder</message>\r\n<message>1--added projectName parameter to the JARFileBuilder&\#x0A;2--added some MANIFEST.MF parameters to the JARFileBuilder&\#x0A;3--added configuration dir to the JARFileBuilder&\#x0A;4--added projectName to buildProject</message>\r\n<message>init commit of 4 Orion libraries</message>\r\n<message>1--created Eclipse project&\#x0A;2--init commit of snippets for the Orion Dependency Injector</message>\r\n<message>created these 2 generic interfaces that will be extended by this&\#x0A;project&apos;s services and service tasks</message>\r\n<message>created DataStructureFacade interface that represents a generic facade&\#x0A;interface that all facades in this project will extend</message>\r\n<message>created DataStructure interface that represents a generic data&\#x0A;structure. Custom collections and data structures will extend this&\#x0A;interface</message>\r\n<message>added getSize()</message>\r\n<message>1--created testsrc dir&\#x0A;2--created a generic interface that many interfaces will extend</message>\r\n<message>1--renamed a method&\#x0A;2--removed a comment</message>\r\n<message>created Ant builder</message>\r\n<message>added configuration project builder</message>\r\n<message>added data-structures project builder</message>\r\n<message>created project Ant builder</message>\r\n<message>1--made DesignPatternService an abstract interface&\#x0A;2--created DesignPatternFacade</message>\r\n<message>made all interfaces abstract interfaces</message>\r\n<message>created checklist.txt that has things/tasks that have to be done by the&\#x0A;developer when they do various stuff</message>\r\n<message>changed filters varName to filtersList</message>\r\n<message>init commit of pipeline, filters and pipeline service</message>\r\n<message>created OrionInterface which is an abstract interface. Other interfaces&\#x0A;will extend it. I am not using the OrionObject for interfaces, because&\#x0A;OrionObject suggests objects and interfaces are not objects. Only&\#x0A;classes and abstract classes will extend OrionObject</message>\r\n<message>added data-structures project as a dependency</message>\r\n<message>added task</message>\r\n<message>1--added configuration project as dependency&\#x0A;2--created Pipeline.prop which is the configuration for the pipeline&\#x0A;pattern. It declares the classes it should check to see if the filter&\#x0A;input is an allowed class type. It also declares the method name to run&\#x0A;for each since the names are different</message>\r\n<message>the JAR file creator now includes the prop files from each project&apos;s&\#x0A;configuration dir</message>\r\n<message>1--updated tasks&\#x0A;2--created Eclipse project</message>\r\n<message>created OrionServiceTask that represents a task a service will execute.&\#x0A;Each service class will do at least one task. Each of these tasks will&\#x0A;be declared/implemented in a service task class and the service class&\#x0A;will use them</message>\r\n<message>created OrionAbstractFunction which represents a functional interfaces&apos;s&\#x0A;implementation and it has one method\: executeFunction(). This method&\#x0A;executes the underlying function that is implemented</message>\r\n<message>created OrionFunction which represents a functional interface</message>\r\n<message>1--renamed&\#x0A;2--converted to interface</message>\r\n<message>created getNumberOfFilters()</message>\r\n<message>1--renamed files&\#x0A;2--updated references&\#x0A;3-created PipelineServiceImpl</message>\r\n<message>renamed the interface and converted it to an abstract class</message>\r\n<message>updated package structure</message>\r\n<message>1--renamed AbstractContainer to OrionContainer&\#x0A;2--converted OrionContainer to an interface</message>\r\n<message>1--renamed interfaces&\#x0A;2--moved everything to the core package&\#x0A;3--created OrionFacade that represents a facade to be extended by other&\#x0A;facades</message>\r\n<message>created PipelineService that will be the entry point to the pipe/filters&\#x0A;design pattern</message>\r\n<message>created DesignPatternService interface that represents what the name&\#x0A;suggests. It will be extended/implemented by design pattern service&\#x0A;interfaces and services</message>\r\n</messages>
commit_dialog_history_size=1000
eclipse.preferences.version=1
